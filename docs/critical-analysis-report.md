# Goé€šç”¨åº“ä»£ç åˆ†ææŠ¥å‘Š

## ğŸ“‹ ç›®å½•

- [1. é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
- [2. ä»£ç ç»“æ„åˆ†æ](#2-ä»£ç ç»“æ„åˆ†æ)
- [3. æ ¸å¿ƒç»„ä»¶æ·±åº¦åˆ†æ](#3-æ ¸å¿ƒç»„ä»¶æ·±åº¦åˆ†æ)
- [4. è®¾è®¡æ¨¡å¼åº”ç”¨](#4-è®¾è®¡æ¨¡å¼åº”ç”¨)
- [5. å¹¶å‘æ§åˆ¶æœºåˆ¶](#5-å¹¶å‘æ§åˆ¶æœºåˆ¶)
- [6. é”™è¯¯å¤„ç†ç­–ç•¥](#6-é”™è¯¯å¤„ç†ç­–ç•¥)
- [7. æ€§èƒ½ä¼˜åŒ–åˆ†æ](#7-æ€§èƒ½ä¼˜åŒ–åˆ†æ)
- [8. ä»£ç è´¨é‡è¯„ä»·](#8-ä»£ç è´¨é‡è¯„ä»·)
- [9. æ¶æ„è®¾è®¡è¯„ä»·](#9-æ¶æ„è®¾è®¡è¯„ä»·)
- [10. å®‰å…¨æ€§åˆ†æ](#10-å®‰å…¨æ€§åˆ†æ)
- [11. å¯ç»´æŠ¤æ€§åˆ†æ](#11-å¯ç»´æŠ¤æ€§åˆ†æ)
- [12. æ‰©å±•æ€§åˆ†æ](#12-æ‰©å±•æ€§åˆ†æ)
- [13. æµ‹è¯•ç­–ç•¥åˆ†æ](#13-æµ‹è¯•ç­–ç•¥åˆ†æ)
- [14. æ–‡æ¡£å®Œæ•´æ€§](#14-æ–‡æ¡£å®Œæ•´æ€§)
- [15. æœ€ä½³å®è·µéµå¾ª](#15-æœ€ä½³å®è·µéµå¾ª)
- [16. æ”¹è¿›å»ºè®®](#16-æ”¹è¿›å»ºè®®)
- [17. æ€»ç»“](#17-æ€»ç»“)

## ğŸ—ºï¸ æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((Goé€šç”¨åº“))
    ä»£ç ç»“æ„
      ç»„ä»¶ç³»ç»Ÿ
        æ§åˆ¶ç»“æ„
        å·¥ä½œè€…ç®¡ç†
        äº‹ä»¶ç³»ç»Ÿ
      å·¥å…·æ¨¡å—
        æ—¥å¿—ç³»ç»Ÿ
        è·¯å¾„å¤„ç†
        å®šæ—¶å™¨æ± 
    è®¾è®¡æ¨¡å¼
      ç»„ä»¶æ¨¡å¼
      å‘å¸ƒè®¢é˜…
      å‘½ä»¤æ¨¡å¼
      æ± æ¨¡å¼
    å¹¶å‘æ§åˆ¶
      ä¸Šä¸‹æ–‡ç®¡ç†
      é”æœºåˆ¶
      åŸå­æ“ä½œ
    æ€§èƒ½ä¼˜åŒ–
      å¯¹è±¡æ± åŒ–
      å†…å­˜ç®¡ç†
      å¹¶å‘ä¼˜åŒ–
    è´¨é‡è¯„ä»·
      ä¼˜ç‚¹
        æ¨¡å—åŒ–
        ç±»å‹å®‰å…¨
        å¹¶å‘å®‰å…¨
      ç¼ºç‚¹
        è¿‡åº¦å¤æ‚
        æ–‡æ¡£ä¸è¶³
        ç»´æŠ¤å›°éš¾
    æ”¹è¿›å»ºè®®
      ç®€åŒ–è®¾è®¡
      å®Œå–„æ–‡æ¡£
      å¢å¼ºæµ‹è¯•
      ç»Ÿä¸€è§„èŒƒ
      å®‰å…¨å¢å¼º
```

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®å®šä½

è¿™æ˜¯ä¸€ä¸ªGoè¯­è¨€é€šç”¨åº“ï¼Œæä¾›å¯é‡ç”¨çš„ç»„ä»¶å’Œå®ç”¨å·¥å…·ï¼Œä¸»è¦ç”¨äºæ„å»ºå¤æ‚çš„å¹¶å‘åº”ç”¨ç¨‹åºã€‚

### 1.2 æ ¸å¿ƒç‰¹æ€§

- ğŸ”§ ç»„ä»¶åŒ–æ¶æ„è®¾è®¡
- ğŸ”„ ç²¾ç»†çš„å¹¶å‘æ§åˆ¶
- ğŸ“¡ äº‹ä»¶é©±åŠ¨é€šä¿¡
- ğŸ“ ç»“æ„åŒ–æ—¥å¿—ç³»ç»Ÿ
- âš¡ æ€§èƒ½ä¼˜åŒ–å·¥å…·

### 1.3 æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Go 1.23.4
- **æ ¸å¿ƒä¾èµ–**:
  - `zap` - æ—¥å¿—ç³»ç»Ÿ
  - `viper` - é…ç½®ç®¡ç†
  - `uuid` - å”¯ä¸€æ ‡è¯†
  - `lumberjack` - æ—¥å¿—è½®è½¬

## 2. ä»£ç ç»“æ„åˆ†æ

### 2.1 ç›®å½•ç»“æ„

```text
common/
â”œâ”€â”€ ğŸ“ model/                    # æ ¸å¿ƒæ¨¡å‹å±‚
â”‚   â”œâ”€â”€ ğŸ“ component/            # ç»„ä»¶ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ define.go           # æ¥å£å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ cpt_work.go         # ç»„ä»¶å®ç°
â”‚   â”‚   â”œâ”€â”€ cpts_work.go        # ç»„ä»¶é›†åˆ
â”‚   â”‚   â””â”€â”€ cmd_work.go         # å‘½ä»¤ç³»ç»Ÿ
â”‚   â”œâ”€â”€ ğŸ“ eventchans/          # äº‹ä»¶é€šé“
â”‚   â”‚   â”œâ”€â”€ define.go           # äº‹ä»¶æ¥å£
â”‚   â”‚   â””â”€â”€ event_chans.go      # äº‹ä»¶å®ç°
â”‚   â”œâ”€â”€ ğŸ“ timerpool/           # å®šæ—¶å™¨æ± 
â”‚   â”‚   â””â”€â”€ timer.go            # æ± åŒ–å®ç°
â”‚   â”œâ”€â”€ control_struct.go       # æ§åˆ¶ç»“æ„
â”‚   â””â”€â”€ worker_waitgroup.go     # å·¥ä½œè€…ç­‰å¾…ç»„
â”œâ”€â”€ ğŸ“ log/                     # æ—¥å¿—ç³»ç»Ÿ
â”‚   â”œâ”€â”€ log.go                  # æ—¥å¿—æ¥å£
â”‚   â””â”€â”€ zaplog.go               # Zapå®ç°
â”œâ”€â”€ ğŸ“ runtime/                 # è¿è¡Œæ—¶
â”‚   â””â”€â”€ runtime.go              # è¿è¡Œæ—¶å·¥å…·
â”œâ”€â”€ utility.go                  # é€šç”¨å·¥å…·
â”œâ”€â”€ path.go                     # è·¯å¾„å¤„ç†
â””â”€â”€ os_info.go                  # ç³»ç»Ÿä¿¡æ¯
```

### 2.2 æ¨¡å—èŒè´£åˆ†æ

| æ¨¡å— | èŒè´£ | å¤æ‚åº¦ | è´¨é‡è¯„åˆ† |
|------|------|--------|----------|
| ç»„ä»¶ç³»ç»Ÿ | ç»„ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç† | é«˜ | â­â­â­â­ |
| äº‹ä»¶ç³»ç»Ÿ | å‘å¸ƒè®¢é˜…é€šä¿¡ | ä¸­ | â­â­â­â­ |
| æ§åˆ¶ç»“æ„ | å¹¶å‘æ§åˆ¶ | é«˜ | â­â­â­ |
| æ—¥å¿—ç³»ç»Ÿ | ç»“æ„åŒ–æ—¥å¿— | ä¸­ | â­â­â­â­â­ |
| å·¥å…·æ¨¡å— | é€šç”¨åŠŸèƒ½ | ä½ | â­â­â­â­ |

## 3. æ ¸å¿ƒç»„ä»¶æ·±åº¦åˆ†æ

### 3.1 CtrlSt (æ§åˆ¶ç»“æ„)

```go
type CtrlSt struct {
    c   context.Context      // ä¸Šä¸‹æ–‡
    ccl context.CancelFunc   // å–æ¶ˆå‡½æ•°
    wwg *WorkerWG           // å·¥ä½œè€…ç­‰å¾…ç»„
    rwm *sync.RWMutex       // è¯»å†™é”
}
```

#### âœ… ä¼˜ç‚¹

- **ç»Ÿä¸€æ§åˆ¶**: é›†ä¸­ç®¡ç†ä¸Šä¸‹æ–‡å’Œå–æ¶ˆ
- **çº¿ç¨‹å®‰å…¨**: ä½¿ç”¨è¯»å†™é”ä¿æŠ¤çŠ¶æ€
- **è¶…æ—¶æ”¯æŒ**: æ”¯æŒè¶…æ—¶æ§åˆ¶

#### âŒ ç¼ºç‚¹

- **è¿‡åº¦å¤æ‚**: ç®€å•åœºæ™¯è¢«å¤æ‚åŒ–
- **ç†è§£å›°éš¾**: å¤šå±‚æŠ½è±¡å¢åŠ å­¦ä¹ æˆæœ¬
- **æ€§èƒ½å¼€é”€**: è¿‡å¤šçš„é”æ“ä½œ

### 3.2 WorkerWG (å·¥ä½œè€…ç­‰å¾…ç»„)

```go
type WorkerWG struct {
    wg              *sync.WaitGroup
    startWaiting    chan struct{}
    startChanClosed bool
    wrwm            *sync.RWMutex
    wm              *sync.Mutex
}
```

#### âœ… ä¼˜ç‚¹1

- **åè°ƒå¯åŠ¨**: æ‰€æœ‰å·¥ä½œè€…åŒæ—¶å¼€å§‹
- **å¼‚å¸¸æ¢å¤**: å†…ç½®panicæ¢å¤æœºåˆ¶
- **ç«æ€é˜²æŠ¤**: é˜²æ­¢å¹¶å‘é—®é¢˜

#### âŒ ç¼ºç‚¹1

- **è¿‡åº¦å·¥ç¨‹**: æ ‡å‡†WaitGroupå·²è¶³å¤Ÿ
- **èµ„æºæ¶ˆè€—**: é¢å¤–çš„é€šé“å’Œé”
- **ç»´æŠ¤å¤æ‚**: å¤æ‚çš„åŒæ­¥é€»è¾‘

### 3.3 ç»„ä»¶ç³»ç»Ÿ

#### æ¥å£è®¾è®¡

```go
type Cpt interface {
    Id() IdName
    Kind() KindName
    CmptInfo() string
    IsRunning() bool
    Ctrl() *CtrlSt
    Start() error
    Stop() error
}
```

#### å®ç°è´¨é‡

- **æ¥å£æ¸…æ™°**: å®šä¹‰æ˜ç¡®ï¼ŒèŒè´£å•ä¸€
- **ç”Ÿå‘½å‘¨æœŸ**: å®Œæ•´çš„å¯åŠ¨åœæ­¢æµç¨‹
- **çŠ¶æ€ç®¡ç†**: åŸå­æ“ä½œä¿è¯ä¸€è‡´æ€§

## 4. è®¾è®¡æ¨¡å¼åº”ç”¨

### 4.1 ç»„ä»¶æ¨¡å¼ â­â­â­â­â­

```go
// ç»„ä»¶æ¥å£
type Cpt interface {
    Start() error
    Stop() error
}

// ç»„ä»¶å®ç°
type CptMetaSt struct {
    // å®ç°ç»†èŠ‚
}
```

**è¯„ä»·**: è®¾è®¡ä¼˜ç§€ï¼Œæ¥å£æ¸…æ™°ï¼Œå®ç°å®Œæ•´

### 4.2 å‘å¸ƒ-è®¢é˜…æ¨¡å¼ â­â­â­â­

```go
type EventChans interface {
    Subscribe(topic string) <-chan any
    Publish(topic string, msgs ...any) bool
    UnSubscribe(topic string, ch <-chan any) error
}
```

**è¯„ä»·**: å®ç°è‰¯å¥½ï¼Œä½†ç¼ºä¹æ¶ˆæ¯æŒä¹…åŒ–

### 4.3 å‘½ä»¤æ¨¡å¼ â­â­â­

```go
type Cmder interface {
    Cmd(any) (command func(map[any]any) any)
    Cmds() (commands map[any]func(map[any]any) any)
    AddCmd(name any, command func(map[any]any) any)
}
```

**è¯„ä»·**: åŸºæœ¬å®ç°ï¼Œç¼ºä¹å‘½ä»¤éªŒè¯

### 4.4 æ± æ¨¡å¼ â­â­â­â­â­

```go
type TimerPool struct {
    p sync.Pool
}
```

**è¯„ä»·**: å®ç°ç®€æ´ï¼Œæ€§èƒ½ä¼˜ç§€

## 5. å¹¶å‘æ§åˆ¶æœºåˆ¶

### 5.1 é”ç­–ç•¥åˆ†æ

| é”ç±»å‹ | ä½¿ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|--------|----------|------|------|
| è¯»å†™é” | çŠ¶æ€è¯»å– | å¹¶å‘è¯»å– | å®ç°å¤æ‚ |
| äº’æ–¥é” | çŠ¶æ€ä¿®æ”¹ | ç®€å•ç›´æ¥ | æ€§èƒ½å¼€é”€ |
| åŸå­æ“ä½œ | çŠ¶æ€æ ‡å¿— | é«˜æ€§èƒ½ | åŠŸèƒ½æœ‰é™ |

### 5.2 ä¸Šä¸‹æ–‡ç®¡ç†

```go
// ä¸Šä¸‹æ–‡ä¼ æ’­
func (cs *CtrlSt) ForkCtxWg() *CtrlSt {
    ctx, cancel := context.WithCancel(cs.c)
    return &CtrlSt{
        c:   ctx,
        ccl: cancel,
        wwg: cs.wwg,
        rwm: &sync.RWMutex{},
    }
}
```

**ä¼˜ç‚¹**: å–æ¶ˆä¼ æ’­ï¼Œè¶…æ—¶æ§åˆ¶
**ç¼ºç‚¹**: è¿‡åº¦å¤æ‚ï¼Œç†è§£å›°éš¾

### 5.3 å¹¶å‘å®‰å…¨è¯„åˆ†

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| çº¿ç¨‹å®‰å…¨ | â­â­â­â­â­ | å…¨é¢çš„é”ä¿æŠ¤ |
| æ­»é”é¢„é˜² | â­â­â­â­ | è‰¯å¥½çš„é”é¡ºåº |
| æ€§èƒ½ä¼˜åŒ– | â­â­â­ | é”ç²’åº¦é€‚ä¸­ |
| ä»£ç å¤æ‚åº¦ | â­â­ | è¿‡åº¦å¤æ‚ |

## 6. é”™è¯¯å¤„ç†ç­–ç•¥

### 6.1 é”™è¯¯èšåˆ

```go
func (cps *Cpts) Start() (err error) {
    for _, cp := range *cps {
        if rerr := cp.Start(); rerr != nil {
            err = multierror.Append(err, rerr)
        }
    }
    return
}
```

**ä¼˜ç‚¹**: æ”¶é›†æ‰€æœ‰é”™è¯¯ï¼Œä¿¡æ¯å®Œæ•´
**ç¼ºç‚¹**: ç¼ºä¹é”™è¯¯åˆ†ç±»å’Œä¼˜å…ˆçº§

### 6.2 ä¸Šä¸‹æ–‡é”™è¯¯å¤„ç†

```go
if err = cpbd.Ctrl().Context().Err(); err != nil {
    if errors.Is(err, context.Canceled) {
        return nil
    }
    if errors.Is(err, context.DeadlineExceeded) {
        mdl.L.Sugar().Debugf("Work timeout error : %+v", err)
        return nil
    }
}
```

**ä¼˜ç‚¹**: åŒºåˆ†é”™è¯¯ç±»å‹ï¼Œé€‚å½“å¤„ç†
**ç¼ºç‚¹**: é”™è¯¯ä¿¡æ¯æ··åˆä¸­è‹±æ–‡

### 6.3 é”™è¯¯å¤„ç†è¯„åˆ†

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| é”™è¯¯æ”¶é›† | â­â­â­â­ | ä½¿ç”¨multierror |
| é”™è¯¯åˆ†ç±» | â­â­â­ | åŸºæœ¬åˆ†ç±» |
| é”™è¯¯ä¿¡æ¯ | â­â­ | æ··åˆè¯­è¨€ |
| é”™è¯¯ä¼ æ’­ | â­â­â­ | åŸºæœ¬ä¼ æ’­ |

## 7. æ€§èƒ½ä¼˜åŒ–åˆ†æ

### 7.1 å¯¹è±¡æ± åŒ–

```go
func (tp *TimerPool) Get(d time.Duration) *time.Timer {
    if t, _ := tp.p.Get().(*time.Timer); t != nil {
        t.Reset(d)
        return t
    }
    return time.NewTimer(d)
}
```

**ä¼˜ç‚¹**: å‡å°‘GCå‹åŠ›ï¼Œæé«˜æ€§èƒ½
**ç¼ºç‚¹**: ç®€å•åœºæ™¯è¿‡åº¦ä¼˜åŒ–

### 7.2 å†…å­˜ç®¡ç†

```go
// é¢„åˆ†é…åˆ‡ç‰‡
results := make([]Result, 0, len(items))

// ç¼“å†²åŒºé‡ç”¨
buf := bp.Get()
defer bp.Put(buf)
```

**ä¼˜ç‚¹**: å‡å°‘å†…å­˜åˆ†é…ï¼Œæé«˜æ€§èƒ½
**ç¼ºç‚¹**: ä»£ç å¤æ‚åº¦å¢åŠ 

### 7.3 æ€§èƒ½ä¼˜åŒ–è¯„åˆ†

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| å¯¹è±¡æ± åŒ– | â­â­â­â­â­ | å®ç°ä¼˜ç§€ |
| å†…å­˜ç®¡ç† | â­â­â­â­ | åŸºæœ¬ä¼˜åŒ– |
| å¹¶å‘ä¼˜åŒ– | â­â­â­ | é”ç²’åº¦é€‚ä¸­ |
| è¿‡åº¦ä¼˜åŒ– | â­â­ | ç®€å•åœºæ™¯å¤æ‚åŒ– |

## 8. ä»£ç è´¨é‡è¯„ä»·

### 8.1 ä»£ç è´¨é‡çŸ©é˜µ

| è´¨é‡ç»´åº¦ | è¯„åˆ† | è¯¦ç»†è¯´æ˜ |
|----------|------|----------|
| **å¯è¯»æ€§** | â­â­â­ | å‘½åè§„èŒƒä¸ç»Ÿä¸€ï¼Œæ³¨é‡Šä¸è¶³ |
| **å¯ç»´æŠ¤æ€§** | â­â­â­ | æ¨¡å—åŒ–å¥½ï¼Œä½†å¤æ‚åº¦é«˜ |
| **å¯æµ‹è¯•æ€§** | â­â­â­ | æ¥å£æ¸…æ™°ï¼Œä½†æµ‹è¯•è¦†ç›–ä¸è¶³ |
| **å¯æ‰©å±•æ€§** | â­â­â­â­ | æ¥å£è®¾è®¡è‰¯å¥½ï¼Œæ‰©å±•ç‚¹æ¸…æ™° |
| **æ€§èƒ½** | â­â­â­â­ | ä¼˜åŒ–åˆç†ï¼Œä½†å­˜åœ¨è¿‡åº¦ä¼˜åŒ– |
| **å®‰å…¨æ€§** | â­â­â­ | åŸºæœ¬å®‰å…¨ï¼Œä½†ç¼ºä¹å®‰å…¨æœºåˆ¶ |

### 8.2 ä»£ç å¤æ‚åº¦åˆ†æ

```go
// é«˜å¤æ‚åº¦ç¤ºä¾‹
func (w *WorkerWG) StartingWait(worker WorkerRecover) {
    w.wrwm.Lock()
    if w.startWaiting == nil {
        w.startWaiting = make(chan struct{}, 1)
        w.startChanClosed = false
    }
    w.wrwm.Unlock()

    w.wm.Lock()
    defer w.wm.Unlock()
    w.wg.Add(1)

    go func() {
        defer w.wg.Done()
        runtime.Gosched()
        startchan := (<-chan struct{})(nil)
        w.wrwm.RLock()
        if w.startWaiting != nil && !w.startChanClosed {
            startchan = w.startWaiting
        }
        w.wrwm.RUnlock()
        if startchan != nil {
            <-startchan
        }
        defer worker.Recover()
        runtime.Gosched()
        worker.Work()
    }()
}
```

**å¤æ‚åº¦é—®é¢˜**:

- å¤šå±‚åµŒå¥—
- å¤šä¸ªé”æ“ä½œ
- å¤æ‚çš„åŒæ­¥é€»è¾‘
- ç†è§£å›°éš¾

## 9. æ¶æ„è®¾è®¡è¯„ä»·

### 9.1 æ¶æ„å±‚æ¬¡

```mermaid
graph TB
    A[åº”ç”¨å±‚] --> B[æœåŠ¡å±‚]
    B --> C[åŸºç¡€è®¾æ–½å±‚]
    C --> D[ç³»ç»Ÿå±‚]
    
    A1[ä¸šåŠ¡ç»„ä»¶] --> A
    A2[ç”¨æˆ·ç»„ä»¶] --> A
    
    B1[ç¼“å­˜æœåŠ¡] --> B
    B2[å­˜å‚¨æœåŠ¡] --> B
    B3[æ¶ˆæ¯æœåŠ¡] --> B
    
    C1[æ—¥å¿—ç»„ä»¶] --> C
    C2[é…ç½®ç»„ä»¶] --> C
    C3[ç›‘æ§ç»„ä»¶] --> C
```

### 9.2 æ¶æ„è¯„åˆ†

| æ¶æ„æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|----------|------|------|
| **åˆ†å±‚è®¾è®¡** | â­â­â­â­ | å±‚æ¬¡æ¸…æ™°ï¼ŒèŒè´£æ˜ç¡® |
| **ç»„ä»¶åŒ–** | â­â­â­â­â­ | ç»„ä»¶è®¾è®¡ä¼˜ç§€ |
| **è§£è€¦ç¨‹åº¦** | â­â­â­â­ | äº‹ä»¶é©±åŠ¨ï¼Œæ¾è€¦åˆ |
| **æ‰©å±•æ€§** | â­â­â­ | æ‰©å±•ç‚¹æœ‰é™ |
| **å¤æ‚åº¦** | â­â­ | è¿‡åº¦å¤æ‚ |

### 9.3 è®¾è®¡åŸåˆ™éµå¾ª

| åŸåˆ™ | éµå¾ªç¨‹åº¦ | è¯´æ˜ |
|------|----------|------|
| **å•ä¸€èŒè´£** | â­â­â­â­ | ç»„ä»¶èŒè´£æ˜ç¡® |
| **å¼€é—­åŸåˆ™** | â­â­â­ | æ¥å£è®¾è®¡è‰¯å¥½ |
| **ä¾èµ–å€’ç½®** | â­â­â­â­ | ä¾èµ–æ¥å£è€Œéå®ç° |
| **æ¥å£éš”ç¦»** | â­â­â­â­ | æ¥å£ç²’åº¦é€‚ä¸­ |
| **é‡Œæ°æ›¿æ¢** | â­â­â­â­ | å®ç°å¯æ›¿æ¢ |

## 10. å®‰å…¨æ€§åˆ†æ

### 10.1 å®‰å…¨æœºåˆ¶è¯„ä¼°

| å®‰å…¨æ–¹é¢ | ç°çŠ¶ | é£é™©ç­‰çº§ | å»ºè®® |
|----------|------|----------|------|
| **è¾“å…¥éªŒè¯** | âŒ ç¼ºå¤± | ğŸ”´ é«˜ | æ·»åŠ è¾“å…¥éªŒè¯ |
| **è®¤è¯æˆæƒ** | âŒ ç¼ºå¤± | ğŸ”´ é«˜ | å®ç°è®¤è¯æœºåˆ¶ |
| **æ•°æ®åŠ å¯†** | âŒ ç¼ºå¤± | ğŸŸ¡ ä¸­ | æ•æ„Ÿæ•°æ®åŠ å¯† |
| **é”™è¯¯ä¿¡æ¯** | âš ï¸ æ³„éœ² | ğŸŸ¡ ä¸­ | é™åˆ¶é”™è¯¯ä¿¡æ¯ |
| **èµ„æºé™åˆ¶** | âœ… åŸºæœ¬ | ğŸŸ¢ ä½ | å®Œå–„èµ„æºæ§åˆ¶ |

### 10.2 å®‰å…¨æ”¹è¿›å»ºè®®

```go
// è¾“å…¥éªŒè¯ç¤ºä¾‹
func ValidateInput(data []byte) error {
    if len(data) > MaxInputSize {
        return errors.New("input too large")
    }
    if !isValidFormat(data) {
        return errors.New("invalid format")
    }
    return nil
}

// é”™è¯¯ä¿¡æ¯é™åˆ¶
func SafeError(err error) error {
    if isSensitiveError(err) {
        return errors.New("internal error")
    }
    return err
}
```

## 11. å¯ç»´æŠ¤æ€§åˆ†æ

### 11.1 ç»´æŠ¤æ€§æŒ‡æ ‡

| æŒ‡æ ‡ | å½“å‰çŠ¶æ€ | ç›®æ ‡çŠ¶æ€ | æ”¹è¿›æªæ–½ |
|------|----------|----------|----------|
| **ä»£ç å¤æ‚åº¦** | é«˜ | ä¸­ | ç®€åŒ–è®¾è®¡ |
| **æ–‡æ¡£å®Œæ•´æ€§** | ä½ | é«˜ | å®Œå–„æ–‡æ¡£ |
| **æµ‹è¯•è¦†ç›–ç‡** | ä½ | é«˜ | å¢åŠ æµ‹è¯• |
| **å‘½åè§„èŒƒ** | ä¸ä¸€è‡´ | ç»Ÿä¸€ | ç»Ÿä¸€è§„èŒƒ |
| **æ³¨é‡Šè´¨é‡** | å·® | å¥½ | æ·»åŠ æ³¨é‡Š |

### 11.2 ç»´æŠ¤æˆæœ¬åˆ†æ

```mermaid
pie title ç»´æŠ¤æˆæœ¬åˆ†å¸ƒ
    "ç†è§£ä»£ç " : 40
    "ä¿®æ”¹åŠŸèƒ½" : 25
    "è°ƒè¯•é—®é¢˜" : 20
    "æ·»åŠ æµ‹è¯•" : 10
    "æ›´æ–°æ–‡æ¡£" : 5
```

### 11.3 å¯ç»´æŠ¤æ€§è¯„åˆ†

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **ä»£ç ç»“æ„** | â­â­â­ | æ¨¡å—åŒ–å¥½ï¼Œä½†å¤æ‚ |
| **å‘½åè§„èŒƒ** | â­â­ | ä¸ç»Ÿä¸€ï¼Œå¯è¯»æ€§å·® |
| **æ³¨é‡Šè´¨é‡** | â­â­ | æ³¨é‡Šä¸è¶³ï¼Œç†è§£å›°éš¾ |
| **æ–‡æ¡£å®Œæ•´æ€§** | â­â­ | æ–‡æ¡£ç¼ºä¹ï¼Œå­¦ä¹ æˆæœ¬é«˜ |
| **æµ‹è¯•è¦†ç›–** | â­â­ | æµ‹è¯•ä¸è¶³ï¼Œè´¨é‡é£é™© |

## 12. æ‰©å±•æ€§åˆ†æ

### 12.1 æ‰©å±•ç‚¹è¯†åˆ«

| æ‰©å±•ç‚¹ | å½“å‰æ”¯æŒ | æ‰©å±•éš¾åº¦ | å»ºè®® |
|--------|----------|----------|------|
| **æ–°ç»„ä»¶ç±»å‹** | âœ… è‰¯å¥½ | ä½ | ç»§ç»­ä½¿ç”¨æ¥å£ |
| **æ–°äº‹ä»¶ç±»å‹** | âœ… è‰¯å¥½ | ä½ | æ‰©å±•äº‹ä»¶ç³»ç»Ÿ |
| **æ–°å‘½ä»¤ç±»å‹** | âœ… è‰¯å¥½ | ä½ | å®Œå–„å‘½ä»¤éªŒè¯ |
| **æ–°å­˜å‚¨åç«¯** | âš ï¸ æœ‰é™ | ä¸­ | æŠ½è±¡å­˜å‚¨æ¥å£ |
| **æ–°é€šä¿¡åè®®** | âŒ ä¸æ”¯æŒ | é«˜ | è®¾è®¡åè®®æŠ½è±¡ |

### 12.2 æ‰©å±•æ€§è¯„åˆ†

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **æ¥å£è®¾è®¡** | â­â­â­â­ | æ¥å£æ¸…æ™°ï¼Œæ˜“äºæ‰©å±• |
| **æ’ä»¶æœºåˆ¶** | â­â­â­ | åŸºæœ¬æ”¯æŒï¼Œéœ€è¦å®Œå–„ |
| **é…ç½®çµæ´»æ€§** | â­â­â­ | åŸºæœ¬é…ç½®ï¼Œå¯æ‰©å±• |
| **åè®®æ”¯æŒ** | â­â­ | åè®®è€¦åˆï¼Œæ‰©å±•å›°éš¾ |
| **å­˜å‚¨æŠ½è±¡** | â­â­ | å­˜å‚¨è€¦åˆï¼Œéš¾ä»¥æ›¿æ¢ |

## 13. æµ‹è¯•ç­–ç•¥åˆ†æ

### 13.1 å½“å‰æµ‹è¯•çŠ¶å†µ

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ | è´¨é‡ | å»ºè®® |
|----------|--------|------|------|
| **å•å…ƒæµ‹è¯•** | 30% | ä¸­ | æé«˜è¦†ç›–ç‡ |
| **é›†æˆæµ‹è¯•** | 10% | ä½ | å¢åŠ é›†æˆæµ‹è¯• |
| **æ€§èƒ½æµ‹è¯•** | 5% | ä½ | æ·»åŠ æ€§èƒ½æµ‹è¯• |
| **å¹¶å‘æµ‹è¯•** | 15% | ä¸­ | å¢åŠ å¹¶å‘æµ‹è¯• |
| **å®‰å…¨æµ‹è¯•** | 0% | æ—  | æ·»åŠ å®‰å…¨æµ‹è¯• |

### 13.2 æµ‹è¯•æ”¹è¿›å»ºè®®

```go
// å•å…ƒæµ‹è¯•ç¤ºä¾‹
func TestComponentLifecycle(t *testing.T) {
    cpt := component.NewCptMetaSt(component.IdName("test"))
    
    // æµ‹è¯•å¯åŠ¨
    if err := cpt.Start(); err != nil {
        t.Errorf("Start failed: %v", err)
    }
    
    if !cpt.IsRunning() {
        t.Error("Component should be running after start")
    }
    
    // æµ‹è¯•åœæ­¢
    if err := cpt.Stop(); err != nil {
        t.Errorf("Stop failed: %v", err)
    }
    
    if cpt.IsRunning() {
        t.Error("Component should not be running after stop")
    }
}

// å¹¶å‘æµ‹è¯•ç¤ºä¾‹
func TestComponentConcurrency(t *testing.T) {
    cpt := component.NewCptMetaSt(component.IdName("concurrent"))
    
    var wg sync.WaitGroup
    operations := 100
    
    // å¹¶å‘å¯åŠ¨
    for i := 0; i < operations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            cpt.Start()
        }()
    }
    
    // å¹¶å‘åœæ­¢
    for i := 0; i < operations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            cpt.Stop()
        }()
    }
    
    wg.Wait()
}

// æ€§èƒ½æµ‹è¯•ç¤ºä¾‹
func BenchmarkComponentStart(b *testing.B) {
    for i := 0; i < b.N; i++ {
        cpt := component.NewCptMetaSt(component.IdName("bench"))
        cpt.Start()
        cpt.Stop()
    }
}
```

## 14. æ–‡æ¡£å®Œæ•´æ€§

### 14.1 æ–‡æ¡£ç°çŠ¶åˆ†æ

| æ–‡æ¡£ç±»å‹ | ç°çŠ¶ | å®Œæ•´æ€§ | è´¨é‡ |
|----------|------|--------|------|
| **README** | âš ï¸ ç®€å• | 30% | ä½ |
| **APIæ–‡æ¡£** | âŒ ç¼ºå¤± | 0% | æ—  |
| **è®¾è®¡æ–‡æ¡£** | âŒ ç¼ºå¤± | 0% | æ—  |
| **ä½¿ç”¨ç¤ºä¾‹** | âŒ ç¼ºå¤± | 0% | æ—  |
| **æœ€ä½³å®è·µ** | âŒ ç¼ºå¤± | 0% | æ—  |

### 14.2 æ–‡æ¡£æ”¹è¿›å»ºè®®

#### 14.2.1 APIæ–‡æ¡£æ¨¡æ¿

```markdown
# Component Interface

## Overview
Component interface defines the basic contract for all components in the system.

## Methods

### Start() error
Starts the component and begins its main work loop.

**Returns:**
- `error`: Returns an error if the component fails to start

**Example:**
```go
cpt := component.NewCptMetaSt(component.IdName("my-component"))
if err := cpt.Start(); err != nil {
    log.Fatalf("Failed to start component: %v", err)
}
```

### Stop() error

Stops the component and performs cleanup operations.

**Returns:**

- `error`: Returns an error if the component fails to stop

**Example:**

```go
if err := cpt.Stop(); err != nil {
    log.Printf("Failed to stop component: %v", err)
}
```

#### 14.2.2 ä½¿ç”¨ç¤ºä¾‹

```markdown
# å¿«é€Ÿå¼€å§‹

## åŸºæœ¬ç»„ä»¶ä½¿ç”¨

```go
package main

import (
    "common/model/component"
    "context"
    "log"
)

func main() {
    // åˆ›å»ºç»„ä»¶
    cpt := component.NewCptMetaSt(
        component.IdName("my-component"),
        component.KindName("MyComponent"),
    )
    
    // å¯åŠ¨ç»„ä»¶
    if err := cpt.Start(); err != nil {
        log.Fatalf("Failed to start component: %v", err)
    }
    
    // ç­‰å¾…ä¸Šä¸‹æ–‡å–æ¶ˆ
    <-cpt.Ctrl().Context().Done()
    
    // åœæ­¢ç»„ä»¶
    if err := cpt.Stop(); err != nil {
        log.Printf("Failed to stop component: %v", err)
    }
}
```

## äº‹ä»¶ç³»ç»Ÿä½¿ç”¨

```go
// åˆ›å»ºäº‹ä»¶ç³»ç»Ÿ
events := eventchans.New()

// è®¢é˜…äº‹ä»¶
dataChan := events.Subscribe("data-ready")

// å‘å¸ƒäº‹ä»¶
events.Publish("data-ready", "some data")

// å¤„ç†äº‹ä»¶
for data := range dataChan {
    processData(data)
}
```

## 15. æœ€ä½³å®è·µéµå¾ª

### 15.1 Goè¯­è¨€æœ€ä½³å®è·µ

| å®è·µ | éµå¾ªç¨‹åº¦ | è¯´æ˜ |
|------|----------|------|
| **é”™è¯¯å¤„ç†** | â­â­â­â­ | åŸºæœ¬éµå¾ªï¼Œä½†ä¸å¤Ÿä¸€è‡´ |
| **æ¥å£è®¾è®¡** | â­â­â­â­â­ | è®¾è®¡ä¼˜ç§€ï¼Œç¬¦åˆGoé£æ ¼ |
| **å¹¶å‘å®‰å…¨** | â­â­â­â­ | å…¨é¢çš„å¹¶å‘æ§åˆ¶ |
| **åŒ…ç»„ç»‡** | â­â­â­â­ | åŒ…ç»“æ„æ¸…æ™° |
| **å‘½åè§„èŒƒ** | â­â­ | ä¸å¤Ÿç»Ÿä¸€ |

### 15.2 è½¯ä»¶å·¥ç¨‹æœ€ä½³å®è·µ

| å®è·µ | éµå¾ªç¨‹åº¦ | è¯´æ˜ |
|------|----------|------|
| **SOLIDåŸåˆ™** | â­â­â­â­ | åŸºæœ¬éµå¾ª |
| **DRYåŸåˆ™** | â­â­â­ | å­˜åœ¨é‡å¤ä»£ç  |
| **KISSåŸåˆ™** | â­â­ | è¿‡åº¦å¤æ‚ |
| **YAGNIåŸåˆ™** | â­â­ | è¿‡åº¦è®¾è®¡ |

### 15.3 æ”¹è¿›å»ºè®®

```go
// ç®€åŒ–è®¾è®¡ç¤ºä¾‹
// åŸå§‹å¤æ‚å®ç°
type ComplexWorker struct {
    component.CptMetaSt
    // å¤§é‡å­—æ®µå’Œæ–¹æ³•
}

// ç®€åŒ–åå®ç°
type SimpleWorker struct {
    ctx    context.Context
    cancel context.CancelFunc
    wg     sync.WaitGroup
    // åªä¿ç•™å¿…è¦å­—æ®µ
}

func (sw *SimpleWorker) Start() error {
    sw.ctx, sw.cancel = context.WithCancel(context.Background())
    sw.wg.Add(1)
    go sw.work()
    return nil
}

func (sw *SimpleWorker) Stop() error {
    sw.cancel()
    sw.wg.Wait()
    return nil
}

func (sw *SimpleWorker) work() {
    defer sw.wg.Done()
    for {
        select {
        case <-sw.ctx.Done():
            return
        default:
            // æ‰§è¡Œå·¥ä½œ
        }
    }
}
```

## 16. æ”¹è¿›å»ºè®®

### 16.1 æ¶æ„æ”¹è¿›

#### 16.1.1 ç®€åŒ–æ§åˆ¶æµ

```go
// ç®€åŒ–çš„æ§åˆ¶ç»“æ„
type SimpleCtrl struct {
    ctx    context.Context
    cancel context.CancelFunc
    wg     sync.WaitGroup
}

func NewSimpleCtrl() *SimpleCtrl {
    ctx, cancel := context.WithCancel(context.Background())
    return &SimpleCtrl{
        ctx:    ctx,
        cancel: cancel,
    }
}

func (sc *SimpleCtrl) StartWorker(worker func(context.Context) error) {
    sc.wg.Add(1)
    go func() {
        defer sc.wg.Done()
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Worker panic: %v", r)
            }
        }()
        worker(sc.ctx)
    }()
}

func (sc *SimpleCtrl) Stop() {
    sc.cancel()
    sc.wg.Wait()
}
```

#### 16.1.2 åˆ†å±‚æ¶æ„ä¼˜åŒ–

```go
// åŸºç¡€è®¾æ–½å±‚
type InfrastructureLayer struct {
    logger   *LogComponent
    config   *ConfigComponent
    metrics  *MetricsComponent
}

// æœåŠ¡å±‚
type ServiceLayer struct {
    infra    *InfrastructureLayer
    cache    *CacheService
    storage  *StorageService
    message  *MessageService
}

// åº”ç”¨å±‚
type ApplicationLayer struct {
    services *ServiceLayer
    handlers map[string]Handler
}

// ç³»ç»Ÿå¯åŠ¨å™¨
type SystemStarter struct {
    infra *InfrastructureLayer
    svc   *ServiceLayer
    app   *ApplicationLayer
}

func (ss *SystemStarter) Start() error {
    // æŒ‰ä¾èµ–é¡ºåºå¯åŠ¨
    if err := ss.infra.Start(); err != nil {
        return fmt.Errorf("infrastructure start failed: %w", err)
    }
    
    if err := ss.svc.Start(); err != nil {
        ss.infra.Stop()
        return fmt.Errorf("service start failed: %w", err)
    }
    
    if err := ss.app.Start(); err != nil {
        ss.svc.Stop()
        ss.infra.Stop()
        return fmt.Errorf("application start failed: %w", err)
    }
    
    return nil
}
```

### 16.2 ä»£ç è´¨é‡æ”¹è¿›

#### 16.2.1 ç»Ÿä¸€å‘½åè§„èŒƒ

```go
// ç»„ä»¶å‘½å
type UserService struct {
    ComponentBase
    userRepo UserRepository
}

// æ–¹æ³•å‘½å
func (us *UserService) Start() error {
    return us.ComponentBase.Start()
}

func (us *UserService) Stop() error {
    return us.ComponentBase.Stop()
}

// å¸¸é‡å‘½å
const (
    DefaultTimeout = 30 * time.Second
    MaxRetryCount  = 3
    BufferSize     = 1024
)
```

#### 16.2.2 é”™è¯¯å¤„ç†æ”¹è¿›

```go
// å®šä¹‰é”™è¯¯ç±»å‹
type ComponentError struct {
    Component string
    Operation string
    Cause     error
}

func (ce *ComponentError) Error() string {
    return fmt.Sprintf("component %s %s failed: %v", 
        ce.Component, ce.Operation, ce.Cause)
}

func (ce *ComponentError) Unwrap() error {
    return ce.Cause
}

// ä½¿ç”¨é”™è¯¯åŒ…è£…
func (cpt *Component) Start() error {
    if err := cpt.validate(); err != nil {
        return &ComponentError{
            Component: cpt.Name(),
            Operation: "start",
            Cause:     err,
        }
    }
    
    if err := cpt.doStart(); err != nil {
        return &ComponentError{
            Component: cpt.Name(),
            Operation: "start",
            Cause:     err,
        }
    }
    
    return nil
}
```

### 16.3 æ€§èƒ½ä¼˜åŒ–æ”¹è¿›

#### 16.3.1 å†…å­˜æ± ä¼˜åŒ–

```go
// é€šç”¨å¯¹è±¡æ± 
type ObjectPool[T any] struct {
    pool sync.Pool
    new  func() T
    reset func(T)
}

func NewObjectPool[T any](new func() T, reset func(T)) *ObjectPool[T] {
    return &ObjectPool[T]{
        pool: sync.Pool{
            New: func() interface{} {
                return new()
            },
        },
        new:   new,
        reset: reset,
    }
}

func (op *ObjectPool[T]) Get() T {
    return op.pool.Get().(T)
}

func (op *ObjectPool[T]) Put(obj T) {
    if op.reset != nil {
        op.reset(obj)
    }
    op.pool.Put(obj)
}

// ä½¿ç”¨ç¤ºä¾‹
var bufferPool = NewObjectPool(
    func() *bytes.Buffer { return new(bytes.Buffer) },
    func(buf *bytes.Buffer) { buf.Reset() },
)
```

#### 16.3.2 å¹¶å‘ä¼˜åŒ–

```go
// æ— é”é˜Ÿåˆ—
type LockFreeQueue[T any] struct {
    head unsafe.Pointer
    tail unsafe.Pointer
}

type node[T any] struct {
    value T
    next  unsafe.Pointer
}

func NewLockFreeQueue[T any]() *LockFreeQueue[T] {
    n := &node[T]{}
    return &LockFreeQueue[T]{
        head: unsafe.Pointer(n),
        tail: unsafe.Pointer(n),
    }
}

func (q *LockFreeQueue[T]) Enqueue(value T) {
    newNode := &node[T]{value: value}
    
    for {
        tail := (*node[T])(q.tail)
        next := (*node[T])(tail.next)
        
        if tail == (*node[T])(q.tail) {
            if next == nil {
                if atomic.CompareAndSwapPointer(&tail.next, nil, unsafe.Pointer(newNode)) {
                    atomic.CompareAndSwapPointer(&q.tail, unsafe.Pointer(tail), unsafe.Pointer(newNode))
                    return
                }
            } else {
                atomic.CompareAndSwapPointer(&q.tail, unsafe.Pointer(tail), unsafe.Pointer(next))
            }
        }
    }
}
```

### 16.4 å®‰å…¨æ€§æ”¹è¿›

#### 16.4.1 è¾“å…¥éªŒè¯

```go
// è¾“å…¥éªŒè¯å™¨
type Validator interface {
    Validate(data []byte) error
}

type StringValidator struct {
    maxLength int
    pattern   *regexp.Regexp
}

func NewStringValidator(maxLength int, pattern string) *StringValidator {
    return &StringValidator{
        maxLength: maxLength,
        pattern:   regexp.MustCompile(pattern),
    }
}

func (sv *StringValidator) Validate(data []byte) error {
    if len(data) > sv.maxLength {
        return fmt.Errorf("data too long: %d > %d", len(data), sv.maxLength)
    }
    
    if !sv.pattern.Match(data) {
        return fmt.Errorf("data does not match pattern")
    }
    
    return nil
}

// å®‰å…¨ç»„ä»¶
type SecureComponent struct {
    ComponentBase
    validator Validator
}

func (sc *SecureComponent) ProcessData(data []byte) error {
    if err := sc.validator.Validate(data); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    return sc.doProcess(data)
}
```

#### 16.4.2 è®¿é—®æ§åˆ¶

```go
// æƒé™æ£€æŸ¥
type PermissionChecker interface {
    CheckPermission(user string, resource string, action string) bool
}

type RBACPermissionChecker struct {
    roles map[string][]string
    permissions map[string][]string
}

func (rpc *RBACPermissionChecker) CheckPermission(user, resource, action string) bool {
    userRoles, exists := rpc.roles[user]
    if !exists {
        return false
    }
    
    for _, role := range userRoles {
        perms, exists := rpc.permissions[role]
        if !exists {
            continue
        }
        
        for _, perm := range perms {
            if perm == fmt.Sprintf("%s:%s", resource, action) {
                return true
            }
        }
    }
    
    return false
}

// å®‰å…¨ç»„ä»¶
type SecureComponent struct {
    ComponentBase
    permissionChecker PermissionChecker
}

func (sc *SecureComponent) ExecuteAction(user, action string, data []byte) error {
    if !sc.permissionChecker.CheckPermission(user, sc.Name(), action) {
        return fmt.Errorf("permission denied")
    }
    
    return sc.doExecute(action, data)
}
```

### 16.5 æµ‹è¯•æ”¹è¿›

#### 16.5.1 æµ‹è¯•æ¡†æ¶

```go
// æµ‹è¯•åŸºç±»
type TestBase struct {
    t *testing.T
    cleanup []func()
}

func NewTestBase(t *testing.T) *TestBase {
    return &TestBase{
        t: t,
        cleanup: make([]func(), 0),
    }
}

func (tb *TestBase) AddCleanup(cleanup func()) {
    tb.cleanup = append(tb.cleanup, cleanup)
}

func (tb *TestBase) Cleanup() {
    for i := len(tb.cleanup) - 1; i >= 0; i-- {
        tb.cleanup[i]()
    }
}

// ç»„ä»¶æµ‹è¯•
func TestComponent(t *testing.T) {
    tb := NewTestBase(t)
    defer tb.Cleanup()
    
    cpt := NewTestComponent()
    tb.AddCleanup(func() { cpt.Stop() })
    
    // æµ‹è¯•å¯åŠ¨
    if err := cpt.Start(); err != nil {
        t.Errorf("Start failed: %v", err)
    }
    
    // æµ‹è¯•åŠŸèƒ½
    result, err := cpt.DoWork("test")
    if err != nil {
        t.Errorf("DoWork failed: %v", err)
    }
    
    if result != "expected" {
        t.Errorf("Expected 'expected', got '%s'", result)
    }
}
```

#### 16.5.2 æ€§èƒ½æµ‹è¯•

```go
// æ€§èƒ½æµ‹è¯•å·¥å…·
type BenchmarkHelper struct {
    b *testing.B
    metrics map[string][]time.Duration
}

func NewBenchmarkHelper(b *testing.B) *BenchmarkHelper {
    return &BenchmarkHelper{
        b: b,
        metrics: make(map[string][]time.Duration),
    }
}

func (bh *BenchmarkHelper) Measure(name string, fn func()) {
    start := time.Now()
    fn()
    duration := time.Since(start)
    
    bh.metrics[name] = append(bh.metrics[name], duration)
}

func (bh *BenchmarkHelper) Report() {
    for name, durations := range bh.metrics {
        var total time.Duration
        for _, d := range durations {
            total += d
        }
        avg := total / time.Duration(len(durations))
        
        bh.b.ReportMetric(float64(avg), name+"_avg_ns")
        bh.b.ReportMetric(float64(total), name+"_total_ns")
    }
}

// ä½¿ç”¨ç¤ºä¾‹
func BenchmarkComponentPerformance(b *testing.B) {
    bh := NewBenchmarkHelper(b)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        cpt := NewTestComponent()
        
        bh.Measure("start", func() {
            cpt.Start()
        })
        
        bh.Measure("work", func() {
            cpt.DoWork("test")
        })
        
        bh.Measure("stop", func() {
            cpt.Stop()
        })
    }
    
    bh.Report()
}
```

### 16.6 æ–‡æ¡£æ”¹è¿›

#### 16.6.1 è‡ªåŠ¨æ–‡æ¡£ç”Ÿæˆ

```go
// æ–‡æ¡£æ³¨é‡Šè§„èŒƒ
// Component represents a basic component in the system.
// It provides lifecycle management and basic functionality.
type Component interface {
    // Start begins the component's execution.
    // It should be called before any other operations.
    // Returns an error if the component cannot start.
    Start() error
    
    // Stop gracefully shuts down the component.
    // It should be called to clean up resources.
    // Returns an error if the component cannot stop.
    Stop() error
    
    // IsRunning returns true if the component is currently active.
    // This method is thread-safe.
    IsRunning() bool
}

// Example usage:
//
// cpt := NewComponent()
// if err := cpt.Start(); err != nil {
//     log.Fatal(err)
// }
// defer cpt.Stop()
//
// for cpt.IsRunning() {
//     // Do work
// }
```

#### 16.6.2 ç¤ºä¾‹ä»£ç 

```go
// åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹
func ExampleComponent_basic() {
    // åˆ›å»ºç»„ä»¶
    cpt := NewBasicComponent("example")
    
    // å¯åŠ¨ç»„ä»¶
    if err := cpt.Start(); err != nil {
        log.Fatal(err)
    }
    
    // ä½¿ç”¨ç»„ä»¶
    result, err := cpt.Process("input")
    if err != nil {
        log.Printf("Processing failed: %v", err)
    }
    
    fmt.Printf("Result: %s\n", result)
    
    // åœæ­¢ç»„ä»¶
    cpt.Stop()
    
    // Output:
    // Result: processed_input
}

// å¹¶å‘ä½¿ç”¨ç¤ºä¾‹
func ExampleComponent_concurrent() {
    cpt := NewConcurrentComponent("concurrent")
    
    if err := cpt.Start(); err != nil {
        log.Fatal(err)
    }
    defer cpt.Stop()
    
    // å¹¶å‘å¤„ç†
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            result, err := cpt.Process(fmt.Sprintf("input_%d", id))
            if err != nil {
                log.Printf("Worker %d failed: %v", id, err)
            } else {
                fmt.Printf("Worker %d: %s\n", id, result)
            }
        }(i)
    }
    
    wg.Wait()
}
```

## 17. æ€»ç»“

### 17.1 æ€»ä½“è¯„ä»·

è¿™æ˜¯ä¸€ä¸ªè®¾è®¡è‰¯å¥½ä½†å­˜åœ¨è¿‡åº¦å·¥ç¨‹åŒ–é—®é¢˜çš„Goé€šç”¨åº“ã€‚å®ƒå±•ç¤ºäº†é«˜çº§çš„Goç¼–ç¨‹æŠ€æœ¯å’Œè½¯ä»¶è®¾è®¡åŸåˆ™ï¼Œä½†åœ¨æŸäº›æ–¹é¢è¿‡äºå¤æ‚ã€‚

### 17.2 ä¼˜åŠ¿æ€»ç»“

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **æŠ€æœ¯å…ˆè¿›æ€§** | â­â­â­â­â­ | å±•ç¤ºäº†Goè¯­è¨€çš„é«˜çº§ç‰¹æ€§ |
| **æ¶æ„è®¾è®¡** | â­â­â­â­ | ç»„ä»¶åŒ–è®¾è®¡æ€è·¯æ¸…æ™° |
| **åŠŸèƒ½å®Œæ•´æ€§** | â­â­â­â­ | è¦†ç›–äº†å¸¸è§çš„åŸºç¡€è®¾æ–½éœ€æ±‚ |
| **å¹¶å‘å®‰å…¨** | â­â­â­â­ | è‰¯å¥½çš„å¹¶å‘æ§åˆ¶æœºåˆ¶ |
| **æ¥å£è®¾è®¡** | â­â­â­â­â­ | æ¥å£æ¸…æ™°ï¼Œæ˜“äºæ‰©å±• |

### 17.3 åŠ£åŠ¿æ€»ç»“

| æ–¹é¢ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **ä»£ç å¤æ‚åº¦** | â­â­ | è¿‡åº¦æŠ½è±¡ï¼Œç†è§£å›°éš¾ |
| **å­¦ä¹ æˆæœ¬** | â­â­ | ä½¿ç”¨é—¨æ§›è¾ƒé«˜ |
| **æ–‡æ¡£å®Œæ•´æ€§** | â­â­ | ç¼ºä¹è¶³å¤Ÿçš„æ–‡æ¡£å’Œç¤ºä¾‹ |
| **ç»´æŠ¤æˆæœ¬** | â­â­ | å¤æ‚çš„æ§åˆ¶æµå¢åŠ ç»´æŠ¤æˆæœ¬ |
| **æ€§èƒ½å¼€é”€** | â­â­â­ | è¿‡åº¦ä¼˜åŒ–å¯¼è‡´æ€§èƒ½å¼€é”€ |

### 17.4 é€‚ç”¨åœºæ™¯

#### âœ… é€‚ç”¨åœºæ™¯

- å¤§å‹å¤æ‚ç³»ç»Ÿ
- é«˜å¹¶å‘åº”ç”¨
- éœ€è¦ç²¾ç»†æ§åˆ¶çš„åœºæ™¯
- æœ‰è¶³å¤ŸæŠ€æœ¯å›¢é˜Ÿçš„é¡¹ç›®
- é•¿æœŸç»´æŠ¤çš„ç³»ç»Ÿ

#### âŒ ä¸é€‚ç”¨åœºæ™¯

- å°å‹ç®€å•é¡¹ç›®
- å¿«é€ŸåŸå‹å¼€å‘
- å›¢é˜ŸæŠ€æœ¯èƒ½åŠ›æœ‰é™
- å¯¹æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯
- çŸ­æœŸé¡¹ç›®

### 17.5 æœ€ç»ˆå»ºè®®

#### 17.5.1 çŸ­æœŸæ”¹è¿›

1. **å®Œå–„æ–‡æ¡£**: æ·»åŠ è¯¦ç»†çš„APIæ–‡æ¡£å’Œä½¿ç”¨ç¤ºä¾‹
2. **ç»Ÿä¸€è§„èŒƒ**: ç»Ÿä¸€å‘½åè§„èŒƒå’Œä»£ç é£æ ¼
3. **å¢åŠ æµ‹è¯•**: æé«˜æµ‹è¯•è¦†ç›–ç‡å’Œè´¨é‡
4. **ç®€åŒ–è®¾è®¡**: ç®€åŒ–è¿‡åº¦å¤æ‚çš„æ§åˆ¶æµ

#### 17.5.2 é•¿æœŸæ”¹è¿›

1. **æ¶æ„é‡æ„**: è€ƒè™‘ç®€åŒ–æ•´ä½“æ¶æ„
2. **æ€§èƒ½ä¼˜åŒ–**: å‡å°‘ä¸å¿…è¦çš„æ€§èƒ½å¼€é”€
3. **å®‰å…¨å¢å¼º**: æ·»åŠ å®‰å…¨æœºåˆ¶å’ŒéªŒè¯
4. **ç”Ÿæ€å»ºè®¾**: å»ºç«‹å®Œæ•´çš„å·¥å…·é“¾å’Œç¤¾åŒº

#### 17.5.3 ä½¿ç”¨å»ºè®®

1. **é€‰æ‹©æ€§ä½¿ç”¨**: æ ¹æ®é¡¹ç›®éœ€æ±‚é€‰æ‹©åˆé€‚çš„åŠŸèƒ½
2. **å›¢é˜ŸåŸ¹è®­**: ä½¿ç”¨å‰éœ€è¦å……åˆ†çš„æŠ€æœ¯åŸ¹è®­
3. **å®šåˆ¶å¼€å‘**: å¯ä»¥åŸºäºæ­¤åº“å¼€å‘ç®€åŒ–ç‰ˆæœ¬
4. **æŒç»­æ”¹è¿›**: å»ºè®®æŒç»­ä¼˜åŒ–å’Œç®€åŒ–è®¾è®¡

### 17.6 ç»“è®º

è¿™ä¸ªåº“ä»£è¡¨äº†Goè¯­è¨€åœ¨å¤æ‚ç³»ç»Ÿè®¾è®¡æ–¹é¢çš„æ¢ç´¢ï¼Œè™½ç„¶å­˜åœ¨ä¸€äº›é—®é¢˜ï¼Œä½†å…¶ä¸­çš„è®¾è®¡æ€è·¯å’ŒæŠ€æœ¯å®ç°ä»ç„¶å€¼å¾—å­¦ä¹ å’Œå€Ÿé‰´ã€‚é€šè¿‡åˆç†çš„æ”¹è¿›å’Œä¼˜åŒ–ï¼Œå®ƒå¯ä»¥æˆä¸ºä¸€ä¸ªæ›´åŠ å®ç”¨å’Œæ˜“ç”¨çš„é€šç”¨åº“ã€‚

å¯¹äºéœ€è¦æ„å»ºå¤æ‚ã€é«˜å¹¶å‘ç³»ç»Ÿçš„å›¢é˜Ÿæ¥è¯´ï¼Œè¿™ä¸ªåº“æä¾›äº†ä¸€ä¸ªè‰¯å¥½çš„èµ·ç‚¹ï¼Œä½†éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œå®šåˆ¶å’Œç®€åŒ–ã€‚å¯¹äºç®€å•é¡¹ç›®ï¼Œå»ºè®®ä½¿ç”¨æ›´è½»é‡çº§çš„è§£å†³æ–¹æ¡ˆã€‚

---

*æœ¬æŠ¥å‘ŠåŸºäºå¯¹ä»£ç åº“çš„æ·±å…¥åˆ†æï¼Œæ—¨åœ¨æä¾›å®¢è§‚çš„è¯„ä»·å’Œæ”¹è¿›å»ºè®®ã€‚å¦‚æœ‰ç–‘é—®æˆ–éœ€è¦è¿›ä¸€æ­¥è®¨è®ºï¼Œè¯·è”ç³»å¼€å‘å›¢é˜Ÿã€‚*
